# Java 虚拟机

## 内存划分及作用

|内存性质|区域|||
|---|---|---|---|
|所有线程共享内存区域|方法区</br>(Method Area)|堆</br>(Heap)||
|线程私有内存区域|虚拟机栈<br/>(VM Stack)|本地方法栈<br/>(Native Method Stack)|程序计数器<br/>(Program Couter Register)

### 1、程序计数器 (Program Couter Register)

程序计数器是Java的字节码指示器，存储当前运行到的**字节码行号**。每个线程都有自己的一个程序计数器。由于Java是通过轮流切换来实现多线程的，所以为了保证下一次切换能恢复到准确的位置运行则要求**各线程有各自的程序计数器**

* 线程私有内存空间
* 唯一没有OOM的区域
* 生命周期跟随线程的生命周期
* 存放内容：
    * 当前字节码执行到的行号

### 2、虚拟机栈（VM Stack）

虚拟机栈即我们常说的“**栈**”，**虚拟机栈描述的是Java方法执行的内存模型**，每个方法在执行的时候都会同时创建一个栈帧（Frame）用于存储**局部变量表**，**操作栈**，**动态链接**，**方法出口**等信息。方法的调用至完成就是一个栈帧的进栈与出栈的过程。

局部变量表存放了编译期间可知的各种基本数据类型（八大基本数据类型）、对象的引用（可以是指向对象的指针、可以是句柄）

局部变量表的所需空间在编译期间完成分配，这个方法需要在帧中所需要的分配多大的空间时完全确定的。在运行过程也不会改变局部变量表的大小

***句柄与指针
句柄与普通指针的区别在于，指针包含的是引用对象的内存地址，而句柄则是由系统所管理的引用标识，该标识可以被系统重新定位到一个内存地址上。这种间接访问对象的模式增强了系统对引用对象的控制。***

当请求的栈深度超出虚拟机所允许的深度则 StackOverflowError
当动态申请的容量超出范围时则抛出 OOM

* 线程私有内存空间
* 生命周期跟随线程的生命周期
* 存储以“栈帧”为单位
* 数据结构模型为栈
* 方法的调用与执行等同与帧的入栈与出栈
* 存放内容：
    * 局部变量表：编译期间可知的**八大类型变量**以及**对象的引用**
    * 操作栈
    * 动态链接
    * 方法出口

### 3、本地方法栈（Native Method Stacks）

本地方法栈作用与虚拟机栈所发挥的作用基本类似，区别在与，**虚拟机栈服务于Java方法**而**本地方法栈服务于 Native 的方法**

### 4、堆（Java Heap）

Java 堆是 Java 虚拟机所管理最大的一块内存区域，这是一块所有线程共享的内存区域。此内存区域的唯一目的就是存放所有的对象实例。绝大多数的对象都在堆中分配内存。

Java 堆是GC发生的主要区域。

Java 堆可以是物理上不连续的内存空间，只需要逻辑上连续即可。如果存放的内容超出其大小时则抛出OOM异常

* 线程共享内存区域
* GC的主要发生区域
* 存放内容：
    * 绝大多数的对象实例

### 5、方法区（Method Area）

方法区是内存共享区域，用于存储已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

因为Java虚拟机规范对此区域的限制非常宽松除了和堆一样可固定大小或可扩展、不需物理连续等之外，GC比较少出现在此区域，GC主要是**针对常量池的回收**和对**类型的卸载**，虽然回收的条件十分苛刻，但是依然回有回收，当方法区无法满足分配需求是，抛出OOM。

* 线程共享内存区域
* 比较少GC的区域
* 存放内容：
    * 已加载的类信息
    * 常量
    * 静态变量

### 6、运行时常量池（Runtime Constant Pool）---方法区的一部分

class 文件中除了有类的**版本**、**字段**、**方法**、**接口**等描述信息以外，还有就是**常量池**，存放了编译期生成的各种**字面量**与**符号引用**，在**类加载**后存放在方法区的**运行时常量池**中。

对于class文件的常量池，运行时常量池还有具有**动态性**的特点，运行期间也可以将新的常量放入池中，这一特性被利用得比较多的有 String 类中的 intern() 方法

* 方法区中的一部分，同是线程共享内存区域
* 类加载完毕后，Class文件中的常量表存放处
* 具有动态性，可以运行时加入
* 存放的内容有：
    * 字面量
    * 符号引用

### 7、直接内存（Direct Momory）

直接内存不是虚拟机的一部分，而是系统的内存的一部分。Java1.4引入了新的输入输出方式可以直接调用Native方法去申请非Java虚拟机部分的内存。

优点：避免了在Java堆和Native堆中来回复制数据。缺点：导致系统内存变小，容易导致OOM

* JVM之外系统内部的内存区域
* 提高了复制数据的效率
* 容易导致OOM


### 总结：

1. #### 程序计数器 (Program Couter Register)
    * ##### 线程私有内存空间
    * ##### 唯一没有OOM的区域
    * ##### 存放内容：
        * 当前字节码执行到的行号
2. #### 虚拟机栈（VM Stack）
    * ##### 线程私有内存空间
    * ##### 存储以“栈帧”为单位
    * ##### 数据结构模型为栈
    * ##### 方法的调用与执行等同与帧的入栈与出栈
    * ##### 存放内容：
        * 局部变量表：编译期间可知的**八大类型变量**以及**对象的引用**
        * 操作栈
        * 动态链接
        * 方法出口
3. #### 本地方法栈（Native Method Stacks）
    * ##### 基本同虚拟机栈
4. #### 堆（Java Heap）
    * ##### 线程共享内存区域
    * ##### GC的主要发生区域
    * ##### 存放内容：
        * 绝大多数的对象实例
5. #### 方法区（Method Area）
    * ##### 线程共享内存区域
    * ##### 比较少GC的区域
    * ##### 存放内容：
        * 已加载的类信息
        * 常量
        * 静态变量
6. #### 运行时常量池（Runtime Constant Pool）---方法区的一部分
    * ##### 方法区中的一部分，同是线程共享内存区域
    * ##### 类加载完毕后，Class文件中的常量表存放处
    * ##### 具有动态性，可以运行时加入
    * ##### 存放的内容有：
        * 字面量
        * 符号引用
7. #### 直接内存（Direct Momory）
    * ##### JVM之外系统内部的内存区域
    * ##### 提高了复制数据的效率
    * ##### 容易导致OOM


## 垃圾收集 GC

GC 需要完成三件事：
* witch？（那些需要被回收）
* when？（什么时候回收）
* how？（怎么回收）

### 1、哪些对象已死？

#### 1.1、引用计数法

引用计数法的思想为：给对象一个计数器用于统计当前引用该对象的引用数量，多一个则+1，少一个则-1，任何时刻都为0的对象则是不可能再被使用的。

大部分情况下都为一个好算法，Java 不使用的原因是：**它很难解决对象循环引用的问题**

如：
a.b = b;
b.a = a;

因为各自都被各自引用，所以计数器永远为1，此时引用计数法则无法判断其存活与否。

#### 1.2、根搜索法

通过搜索算法，从一系列的 “GC Root” 为起点向下搜索，搜索过程所有走过的路径称为引用链，再引用链以外的对象都判断为 “死” 对象

Java中作为 GC Roots 的有：
* 虚拟机栈中（栈帧中局部变量表）中的引用对象
* 方法区中的静态属性引用的对象
* 方法去中的常量引用的对象
* 本地方法栈中JNI的引用对象


### 2、分级的引用

引用的分级

1. **强引用**：如 “ A a = new A()” 这一类对象，只要强引用在，对象就永远不会被GC
2. **软引用**：描述一些有点用，但是非必须的对象，在内存溢出之前会先把这些对象回收掉，然后还是不够空间才会抛出OOM异常
3. **弱引用**：描述比弱引用更弱的对象，被弱引用的对象只能生存到下一次GC，不管是否内存不足，只要GC就会被回收
4. **虚引用**：虚引用对于对象来说完全不会收到影响，也无法通过虚引用获取一个对象，设置虚引用的唯一目的是在对象被回收时能收到一个系统通知

### 3、生存或死亡

不可到达的对象并非“必死”，将暂时处于“缓刑”阶段，要真正宣告对象死忙，**至少要经历两次标记过程**

当根搜索后发现没有与GC Roots 相连接的引用链，对象将被第一次标记并进行一次筛选，筛选条件是此对象是否有必要执行 finalize() 方法。**对象没有覆盖 finalize()** 或 **finalize() 已经被虚拟机调用过**，**虚拟机都认为是没必要执行 finalize()**。

如果这个对象被判断为需要执行 finalize() 方法时，那么这个对象将会放置在**F-Queue队列**中，并最后由虚拟机自动建立的、低优先级的Finalizer线程去执行（调用这些对象的 finalize() 方法）。**并不保证 finalize() 完全执行完**，以防执行缓慢以及发生死循环

对象要在 finalize() 中拯救自己则需要让自己与引用链上的对象建立关联

虽然可以在 finalize() 中拯救自己，但只能一次，下一次就会跳过 finalize()，直接回收

### 4、回收方法区

方法区的GC主要回收：**废弃常量**和**无用的类**。

**废弃常量**：废弃常量的回收类似堆中的对象回收，主要看是否还存在对该常量的引用，如果没有则将该常量清除出常量池，（如：常量池的“abc”在程序中没有有效的引用指向它，然后就会被清除掉）

**无用的类**：
* 该类的所有实例已被回收，Java堆中不含任何该类的对象实例
* 加载该类的 ClassLoader 已经被回收
* 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问到该类

### 5、GC算法

#### 5.1、标记清除算法

“标记 - 清除”（ Mark-Sweep ）算法分为标记与清除两个过程，先扫描一遍，标记需要清除的对象，再遍历一次清除已标记的对象。

缺点：
* 效率问题，标记和清除过程都效率不高
* 空间问题，标记清除过后会产生大量不连续内存碎片，碎片过多会导致体量较大对象无法分配空间而要再次GC

#### 5.2、复制算法

* 将内存划分为A、B两块
* 将A中的存活对象复制到B中，清空A
* 将B中的存活对象复制到A中，清空B
* ...如此往复

基于标记清除算法，将内存空间划分为等大的两块，将存活的对象从A复制到B，然后清空A，B空间用完就复制B的存活对象到A并清空B，如此往复

优点：复制完的对象顺序摆放，高效。
缺点：内存强行缩小了一半，空间代价太高

新生代使用该算法回收空间，新生代内存划分为较大的 Eden 和两块较小的 Survivor ，Eden ： Survivor = 8:1。**在回收时，将 Eden 和 Survivor 中的存活对象存放至另一个 Survivor 中，当 Survivor 中空间不够时，剩余对象会被划入老年代**

当收集**对象存活率较高时，复制操作就就过多而影响效率**；如果不想浪费50%的空间就需要额外的空间做担保，还要应对对象100%存活的极端情况

#### 5.3、标记-整理 算法

* 标记：先对区域遍历一遍找出可清除对象
* 整理：将存活对象都移向一端，然后清除掉边界以外的部分

这是老年代的算法

#### 5.4、分代收集算法

现在市面上大部分的虚拟机都采用分代收集算法，根据对象的生命周期划分到不同的内存区域。一般分为“新生代”与“永久代”。

**新生代**：由于新生代中对象存活率低，采用“**复制算法**”

**永久代**：由于永久代中对象存活率高，采用“**标记 - 整理**”或“**标记- 清除**”算法
